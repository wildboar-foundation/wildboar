:orphan:

:py:mod:`wildboar.explain.counterfactual._proto`
================================================

.. py:module:: wildboar.explain.counterfactual._proto


Module Contents
---------------

Classes
~~~~~~~

.. autoapisummary::

   wildboar.explain.counterfactual._proto.DynamicTimeWarpTransform
   wildboar.explain.counterfactual._proto.EuclideanTransform
   wildboar.explain.counterfactual._proto.KNearestPrototypeSampler
   wildboar.explain.counterfactual._proto.KNearestShapeletPrototypeSampler
   wildboar.explain.counterfactual._proto.MetricTransform
   wildboar.explain.counterfactual._proto.PredictEvaluator
   wildboar.explain.counterfactual._proto.ProbabilityEvaluator
   wildboar.explain.counterfactual._proto.PrototypeCounterfactual
   wildboar.explain.counterfactual._proto.PrototypeSampler
   wildboar.explain.counterfactual._proto.ShapeletPrototypeSampler
   wildboar.explain.counterfactual._proto.TargetEvaluator
   wildboar.explain.counterfactual._proto.UniformPrototypeSampler
   wildboar.explain.counterfactual._proto.WeightedDynamicTimeWarpTransform




.. py:class:: DynamicTimeWarpTransform(gamma, r=1.0)

   Bases: :py:obj:`MetricTransform`

   Transform a sample by moving it closer using the dtw alignment matrix

   Construct a new transformer

   :param gamma: The strength of the move, where values close to 0 means that the
                 sample is moved less and values closer to 1 mean that the sample
                 is moved more.
   :type gamma: float

   .. py:method:: move(o, p)

      Move the sample o towards p

      :param o: An array, the time series to move
      :type o: ndarray of shape (n_timestep,)
      :param p: An array, the time series to move towards
      :type p: ndarray of shape (n_timestep,)

      :returns: **ndarray**
      :rtype: an array, the result of moving o closer to p



.. py:class:: EuclideanTransform(gamma)

   Bases: :py:obj:`MetricTransform`

   Transform a sample by moving it closer in euclidean space

   Construct a new transformer

   :param gamma: The strength of the move, where values close to 0 means that the
                 sample is moved less and values closer to 1 mean that the sample
                 is moved more.
   :type gamma: float

   .. py:method:: move(o, p)

      Move the sample o towards p

      :param o: An array, the time series to move
      :type o: ndarray of shape (n_timestep,)
      :param p: An array, the time series to move towards
      :type p: ndarray of shape (n_timestep,)

      :returns: **ndarray**
      :rtype: an array, the result of moving o closer to p



.. py:class:: KNearestPrototypeSampler(x, y, prototype_indicies, metric_transform)

   Bases: :py:obj:`PrototypeSampler`

   Sample a prototype among the samples closest to the current counterfactual

   Sample and refine counterfactuals

   :param x: The data samples labeled as y
   :type x: ndarray of shape (n_samples, n_timestep)
   :param y: The label of the samples in x
   :type y: object
   :param n_prototypes: The number of prototypes in the initial sample
   :type n_prototypes: int
   :param metric_transform: The metric transformer.
   :type metric_transform: MetricTransform
   :param random_state: The random number generator.
   :type random_state: RandomState

   .. py:method:: nearest_index(o, random_state)

      Return the index of the closest sample

      :param o: The current counterfactual sample
      :type o: ndarray of shape (n_timestep,)

      :returns: **int**
      :rtype: an index


   .. py:method:: sample(o, random_state)

      Sample an example

      :param o: The current counterfactual sample
      :type o: ndarray of shape (n_timestep,)

      :returns: **prototype** -- A prototype of the counterfactual label
      :rtype: ndarray of shape (n_timestep,)



.. py:class:: KNearestShapeletPrototypeSampler(x, y, prototype_indicies, metric_transform, min_shapelet_size=0, max_shapelet_size=1)

   Bases: :py:obj:`PrototypeSampler`

   Combines the KNearestPrototypeSample and the ShapeletPrototypeSampler
   such that prototype samples are sampled among the nearest neighbors of the
   counterfactual

   Sample and refine counterfactuals

   :param x: The data samples labeled as y
   :type x: ndarray of shape (n_samples, n_timestep)
   :param y: The label of the samples in x
   :type y: object
   :param n_prototypes: The number of prototypes in the initial sample
   :type n_prototypes: int
   :param metric_transform: The metric transformer.
   :type metric_transform: MetricTransform
   :param random_state: The random number generator.
   :type random_state: RandomState

   .. py:method:: move(o, p)

      Move the current counterfactual toward the prototype

      :param o: The current counterfactual sample
      :type o: ndarray of shape (n_timestep,)
      :param p: The prototype of the counterfactual label
      :type p: ndarray of shape (n_timestep,)

      :returns: **new_counterfactual** -- The new counterfactual moved towards the prototype
      :rtype: ndarray of shape (n_timestep,)


   .. py:method:: sample(o, random_state)

      Sample an example

      :param o: The current counterfactual sample
      :type o: ndarray of shape (n_timestep,)

      :returns: **prototype** -- A prototype of the counterfactual label
      :rtype: ndarray of shape (n_timestep,)



.. py:class:: MetricTransform(gamma)

   Bases: :py:obj:`abc.ABC`

   Move a time series towards a prototype

   Construct a new transformer

   :param gamma: The strength of the move, where values close to 0 means that the
                 sample is moved less and values closer to 1 mean that the sample
                 is moved more.
   :type gamma: float

   .. py:method:: move(o, p)
      :abstractmethod:

      Move the sample o towards p

      :param o: An array, the time series to move
      :type o: ndarray of shape (n_timestep,)
      :param p: An array, the time series to move towards
      :type p: ndarray of shape (n_timestep,)

      :returns: **ndarray**
      :rtype: an array, the result of moving o closer to p



.. py:class:: PredictEvaluator(estimator)

   Bases: :py:obj:`TargetEvaluator`

   Evaluate if a counterfactual is predicted as y

   Construct a new evaluator

   :param estimator: The estimator
   :type estimator: object


.. py:class:: ProbabilityEvaluator(estimator, probability=0.5)

   Bases: :py:obj:`TargetEvaluator`

   Evaluate if the probability of a counterfactual is at least a given constant

   Construct a new evaluator

   :param estimator: The estimator
   :type estimator: object
   :param probability: The minimum probability of the predicted label
   :type probability: float


.. py:class:: PrototypeCounterfactual(metric='euclidean', *, r=1.0, g=0.05, max_iter=100, step_size=0.1, n_prototypes='auto', target='auto', method='sample', min_shapelet_size=0.0, max_shapelet_size=1.0, random_state=None, verbose=False)

   Bases: :py:obj:`wildboar.base.CounterfactualMixin`, :py:obj:`wildboar.base.ExplainerMixin`, :py:obj:`wildboar.base.BaseEstimator`

   Model agnostic approach for constructing counterfactual explanations

   .. attribute:: estimator_

      The estimator for which counterfactuals are computed

      :type: object

   .. attribute:: classes_

      The classes

      :type: ndarray

   .. attribute:: partitions_

      Dictionary of classes and PrototypeSampler

      :type: dict

   .. attribute:: target_

      The target evaluator

      :type: TargetEvaluator

   .. rubric:: References

   Samsten, Isak (2020).
       Model agnostic time series counterfactuals

   Crate a new model agnostic counterfactual explainer.

   :param metric: The metric used to move the samples
   :type metric: {'euclidean', 'dtw', 'wdtw'}, optional
   :param r: The warping window size, if metric='dtw' or metric='wdtw'
   :type r: float, optional
   :param g: Penalty control for weighted DTW, if metric='wdtw'
   :type g: float, optional
   :param max_iter: The maximum number of iterations
   :type max_iter: int, optional
   :param step_size: The step size when moving samples toward class prototypes
   :type step_size: float, optional
   :param n_prototypes: The number of initial prototypes to sample from
   :type n_prototypes: int, float or str, optional
   :param target: The target evaluation of counterfactuals:

                  - if 'predict' the counterfactual prediction must return the correct
                    label
                  - if float, the counterfactual prediction probability must
                    exceed target value
   :type target: float or {'predict'}, optional
   :param method: Method for selecting prototypes

                  - if 'sample' a prototype is sampled among the initial prototypes
                  - if 'shapelet' a prototype shapelet is sampled among the initial
                    prototypes
                  - if 'nearest' a prototype is sampled from the closest n prototypes
                  - if 'nearest_shapelet' a prototype shapelet is sampled from the
                    closest n prototypes
   :type method: {'sample', 'shapelet', 'nearest', 'nearest_shapelet'}, optional
   :param min_shapelet_size: Minimum shapelet size, if method='shapelet' or 'nearest_shapelet'
   :type min_shapelet_size: float, optional
   :param max_shapelet_size: Maximum shapelet size, if method='shapelet' or 'nearest_shapelet'
   :type max_shapelet_size: float, optional
   :param random_state: Pseudo-random number for consistency between different runs
   :type random_state: RandomState or int, optional

   .. py:method:: explain(x, y)


   .. py:method:: fit(estimator, x, y)



.. py:class:: PrototypeSampler(x, y, prototype_indices, metric_transform)

   Bases: :py:obj:`abc.ABC`

   Helper class that provides a standard way to create an ABC using
   inheritance.

   Sample and refine counterfactuals

   :param x: The data samples labeled as y
   :type x: ndarray of shape (n_samples, n_timestep)
   :param y: The label of the samples in x
   :type y: object
   :param n_prototypes: The number of prototypes in the initial sample
   :type n_prototypes: int
   :param metric_transform: The metric transformer.
   :type metric_transform: MetricTransform
   :param random_state: The random number generator.
   :type random_state: RandomState

   .. py:method:: move(o, p)

      Move the current counterfactual toward the prototype

      :param o: The current counterfactual sample
      :type o: ndarray of shape (n_timestep,)
      :param p: The prototype of the counterfactual label
      :type p: ndarray of shape (n_timestep,)

      :returns: **new_counterfactual** -- The new counterfactual moved towards the prototype
      :rtype: ndarray of shape (n_timestep,)


   .. py:method:: sample(o, random_state)
      :abstractmethod:

      Sample an example

      :param o: The current counterfactual sample
      :type o: ndarray of shape (n_timestep,)

      :returns: **prototype** -- A prototype of the counterfactual label
      :rtype: ndarray of shape (n_timestep,)


   .. py:method:: sample_move(o, random_state)

      Sampla a prototype and move the counterfactual towards the prototype

      :param o: The current counterfactual sample
      :type o: ndarray of shape (n_timestep,)

      :returns: **new_counterfactual** -- The new counterfactual moved towards the prototype
      :rtype: ndarray of shape (n_timestep,)



.. py:class:: ShapeletPrototypeSampler(x, y, prototype_indicies, metric_transform, min_shapelet_size=0, max_shapelet_size=1)

   Bases: :py:obj:`PrototypeSampler`

   Sample shapelet prototypes

   Sample shapelet

   :param x: The data samples
   :type x: ndarray of shape (n_samples, n_timestep)
   :param y: The label of the samples in x
   :type y: object
   :param metric_transform: The metric transformer.
   :type metric_transform: MetricTransform
   :param random_state: The random number generator.
   :type random_state: RandomState
   :param min_shapelet_size: The minimum shapelet size
   :type min_shapelet_size: float
   :param max_shapelet_size: The maximum shapelet size
   :type max_shapelet_size: float

   .. py:method:: move(o, p)

      Move the best matching shapelet of the  counterfactual sample towards
      the shapelet prototype

      :param o: The counterfactual sample
      :type o: ndarray of shape (n_timestep,)
      :param p: The prototype shapelet
      :type p: ndarray

      :returns: **new_counterfactual** -- The new counterfactual moved towards the prototype
      :rtype: ndarray of shape (n_timestep,)


   .. py:method:: sample(_o, random_state)

      Sample an example

      :param o: The current counterfactual sample
      :type o: ndarray of shape (n_timestep,)

      :returns: **prototype** -- A prototype of the counterfactual label
      :rtype: ndarray of shape (n_timestep,)


   .. py:method:: sample_shapelet(p, random_state)

      Sample a shapelet from x

      :param p: The prototype sample
      :type p: ndarray of shape (n_timestep,)

      :returns: **shapelet** -- A shapelet
      :rtype: ndarray



.. py:class:: TargetEvaluator(estimator)

   Bases: :py:obj:`abc.ABC`

   Evaluate if a sample is a counterfactual

   Construct a new evaluator

   :param estimator: The estimator
   :type estimator: object

   .. py:method:: is_counterfactual(x, y)

      Return true if x is a counterfactual of label y

      :param x: The counterfactual sample
      :type x: ndarray of shape (n_timestep,)
      :param y: The counterfactual label
      :type y: object

      :returns: **bool**
      :rtype: true if counterfactual



.. py:class:: UniformPrototypeSampler(x, y, prototype_indices, metric_transform)

   Bases: :py:obj:`PrototypeSampler`

   Sample a prototype uniformly at random from the initial prototype sample

   Sample and refine counterfactuals

   :param x: The data samples labeled as y
   :type x: ndarray of shape (n_samples, n_timestep)
   :param y: The label of the samples in x
   :type y: object
   :param n_prototypes: The number of prototypes in the initial sample
   :type n_prototypes: int
   :param metric_transform: The metric transformer.
   :type metric_transform: MetricTransform
   :param random_state: The random number generator.
   :type random_state: RandomState

   .. py:method:: sample(_o, random_state)

      Sample an example

      :param o: The current counterfactual sample
      :type o: ndarray of shape (n_timestep,)

      :returns: **prototype** -- A prototype of the counterfactual label
      :rtype: ndarray of shape (n_timestep,)



.. py:class:: WeightedDynamicTimeWarpTransform(gamma, r=1, g=0.05)

   Bases: :py:obj:`DynamicTimeWarpTransform`

   Transform a sample by moving it closer using the dtw alignment matrix

   Construct a new transformer

   :param gamma: The strength of the move, where values close to 0 means that the
                 sample is moved less and values closer to 1 mean that the sample
                 is moved more.
   :type gamma: float


