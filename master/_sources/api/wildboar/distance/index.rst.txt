
***************************
:py:mod:`wildboar.distance`
***************************

.. py:module:: wildboar.distance

.. autoapi-nested-parse::

   
   Fast distance computations.

   The :py:mod:`wildboar.distance` module includes functions for computing
   paired and pairwise distances between time series and between time series and
   subsequences.

   See the :ref:`User Guide <guide-metrics>` for more details and
   examples.















   ..
       !! processed by numpydoc !!


Submodules
==========

.. toctree::
   :titlesonly:
   :maxdepth: 1

   dtw/index.rst


Package Contents
----------------

Classes
-------

.. autoapisummary::

   wildboar.distance.KMeans
   wildboar.distance.KMedoids
   wildboar.distance.KNeighborsClassifier



Functions
---------

.. autoapisummary::

   wildboar.distance.argmin_distance
   wildboar.distance.matrix_profile
   wildboar.distance.paired_distance
   wildboar.distance.paired_subsequence_distance
   wildboar.distance.paired_subsequence_match
   wildboar.distance.pairwise_distance
   wildboar.distance.pairwise_subsequence_distance
   wildboar.distance.subsequence_match



.. py:class:: KMeans(n_clusters=8, *, metric='euclidean', r=1.0, g=None, init='random', n_init='auto', max_iter=300, tol=0.001, verbose=0, random_state=None)




   
   KMeans clustering with support for DTW and weighted DTW.


   :Parameters:

       **n_clusters** : int, optional
           The number of clusters.

       **metric** : {"euclidean", "dtw"}, optional
           The metric.

       **r** : float, optional
           The size of the warping window.

       **g** : float, optional
           SoftDTW penalty. If None, traditional DTW is used.

       **init** : {"random"}, optional
           Cluster initialization. If "random", randomly initialize `n_clusters`.

       **n_init** : "auto" or int, optional
           Number times the algorithm is re-initialized with new centroids.

       **max_iter** : int, optional
           The maximum number of iterations for a single run of the algorithm.

       **tol** : float, optional
           Relative tolerance to declare convergence of two consecutive iterations.

       **verbose** : int, optional
           Print diagnostic messages during convergence.

       **random_state** : RandomState or int, optional
           Determines random number generation for centroid initialization and
           barycentering when fitting with `metric="dtw"`.












   :Attributes:

       **n_iter_** : int
           The number of iterations before convergence.

       **cluster_centers_** : ndarray of shape (n_clusters, n_timestep)
           The cluster centers.

       **labels_** : ndarray of shape (n_samples, )
           The cluster assignment.


   ..
       !! processed by numpydoc !!
   .. py:method:: fit(x, y=None)

      
      Compute the kmeans-clustering.


      :Parameters:

          **x** : univariate time-series
              The input samples.

          **y** : Ignored, optional
              Not used.

      :Returns:

          object
              Fitted estimator.













      ..
          !! processed by numpydoc !!

   .. py:method:: fit_predict(X, y=None)

      
      Perform clustering on `X` and returns cluster labels.


      :Parameters:

          **X** : array-like of shape (n_samples, n_features)
              Input data.

          **y** : Ignored
              Not used, present for API consistency by convention.

      :Returns:

          **labels** : ndarray of shape (n_samples,), dtype=np.int64
              Cluster labels.













      ..
          !! processed by numpydoc !!

   .. py:method:: fit_transform(X, y=None, **fit_params)

      
      Fit to data, then transform it.

      Fits transformer to `X` and `y` with optional parameters `fit_params`
      and returns a transformed version of `X`.

      :Parameters:

          **X** : array-like of shape (n_samples, n_features)
              Input samples.

          **y** :  array-like of shape (n_samples,) or (n_samples, n_outputs),                 default=None
              Target values (None for unsupervised transformations).

          **\*\*fit_params** : dict
              Additional fit parameters.

      :Returns:

          **X_new** : ndarray array of shape (n_samples, n_features_new)
              Transformed array.













      ..
          !! processed by numpydoc !!

   .. py:method:: get_metadata_routing()

      
      Get metadata routing of this object.

      Please check :ref:`User Guide <metadata_routing>` on how the routing
      mechanism works.


      :Returns:

          **routing** : MetadataRequest
              A :class:`~sklearn.utils.metadata_routing.MetadataRequest` encapsulating
              routing information.













      ..
          !! processed by numpydoc !!

   .. py:method:: get_params(deep=True)

      
      Get parameters for this estimator.


      :Parameters:

          **deep** : bool, default=True
              If True, will return the parameters for this estimator and
              contained subobjects that are estimators.

      :Returns:

          **params** : dict
              Parameter names mapped to their values.













      ..
          !! processed by numpydoc !!

   .. py:method:: predict(x)

      
      Predict the closest cluster for each sample.


      :Parameters:

          **x** : univariate time-series
              The input samples.

      :Returns:

          ndarray of shape (n_samples, )
              Index of the cluster each sample belongs to.













      ..
          !! processed by numpydoc !!

   .. py:method:: set_output(*, transform=None)

      
      Set output container.

      See :ref:`sphx_glr_auto_examples_miscellaneous_plot_set_output.py`
      for an example on how to use the API.

      :Parameters:

          **transform** : {"default", "pandas"}, default=None
              Configure output of `transform` and `fit_transform`.
              
              - `"default"`: Default output format of a transformer
              - `"pandas"`: DataFrame output
              - `None`: Transform configuration is unchanged

      :Returns:

          **self** : estimator instance
              Estimator instance.













      ..
          !! processed by numpydoc !!

   .. py:method:: set_params(**params)

      
      Set the parameters of this estimator.

      The method works on simple estimators as well as on nested objects
      (such as :class:`~sklearn.pipeline.Pipeline`). The latter have
      parameters of the form ``<component>__<parameter>`` so that it's
      possible to update each component of a nested object.

      :Parameters:

          **\*\*params** : dict
              Estimator parameters.

      :Returns:

          **self** : estimator instance
              Estimator instance.













      ..
          !! processed by numpydoc !!

   .. py:method:: transform(x)

      
      Transform the input to a cluster distance space.


      :Parameters:

          **x** : univariate time-series
              The input samples.

      :Returns:

          ndarray of shape (n_samples, n_clusters)
              The distance between each sample and each cluster.













      ..
          !! processed by numpydoc !!


.. py:class:: KMedoids(n_clusters=8, metric='euclidean', metric_params=None, init='random', n_init='auto', algorithm='fast', max_iter=30, tol=0.0001, verbose=0, n_jobs=None, random_state=None)




   
   KMedoid algorithm.


   :Parameters:

       **n_clusters** : int, optional
           The number of clusters.

       **metric** : str, optional
           The metric.

       **metric_params** : dict, optional
           The metric parameters. Read more about the metrics and their parameters
           in the :ref:`User guide <list_of_metrics>`.

       **init** : {"auto", "random", "min"}, optional
           Cluster initialization. If "random", randomly initialize `n_clusters`,
           if "min" select the samples with the smallest distance to the other samples.

       **n_init** : "auto" or int, optional
           Number times the algorithm is re-initialized with new centroids.

       **algorithm** : {"fast", "pam"}, optional
           The algorithm for updating cluster assignments. If "pam", use the
           Partitioning Around Medoids algorithm.

       **max_iter** : int, optional
           The maximum number of iterations for a single run of the algorithm.

       **tol** : float, optional
           Relative tolerance to declare convergence of two consecutive iterations.

       **verbose** : int, optional
           Print diagnostic messages during convergence.

       **n_jobs** : int, optional
           The number of jobs to run in parallel. A value of `None` means using
           a single core and a value of `-1` means using all cores. Positive
           integers mean the exact number of cores.

       **random_state** : RandomState or int, optional
           Determines random number generation for centroid initialization and
           barycentering when fitting with `metric="dtw"`.












   :Attributes:

       **n_iter_** : int
           The number of iterations before convergence.

       **cluster_centers_** : ndarray of shape (n_clusters, n_timestep)
           The cluster centers.

       **medoid_indices_** : ndarray of shape (n_clusters, )
           The index of the medoid in the input samples.

       **labels_** : ndarray of shape (n_samples, )
           The cluster assignment.


   ..
       !! processed by numpydoc !!
   .. py:method:: fit(x, y=None)

      
      Compute the kmedoids-clustering.


      :Parameters:

          **x** : univariate time-series
              The input samples.

          **y** : Ignored, optional
              Not used.

      :Returns:

          object
              Fitted estimator.













      ..
          !! processed by numpydoc !!

   .. py:method:: fit_predict(X, y=None)

      
      Perform clustering on `X` and returns cluster labels.


      :Parameters:

          **X** : array-like of shape (n_samples, n_features)
              Input data.

          **y** : Ignored
              Not used, present for API consistency by convention.

      :Returns:

          **labels** : ndarray of shape (n_samples,), dtype=np.int64
              Cluster labels.













      ..
          !! processed by numpydoc !!

   .. py:method:: fit_transform(X, y=None, **fit_params)

      
      Fit to data, then transform it.

      Fits transformer to `X` and `y` with optional parameters `fit_params`
      and returns a transformed version of `X`.

      :Parameters:

          **X** : array-like of shape (n_samples, n_features)
              Input samples.

          **y** :  array-like of shape (n_samples,) or (n_samples, n_outputs),                 default=None
              Target values (None for unsupervised transformations).

          **\*\*fit_params** : dict
              Additional fit parameters.

      :Returns:

          **X_new** : ndarray array of shape (n_samples, n_features_new)
              Transformed array.













      ..
          !! processed by numpydoc !!

   .. py:method:: get_metadata_routing()

      
      Get metadata routing of this object.

      Please check :ref:`User Guide <metadata_routing>` on how the routing
      mechanism works.


      :Returns:

          **routing** : MetadataRequest
              A :class:`~sklearn.utils.metadata_routing.MetadataRequest` encapsulating
              routing information.













      ..
          !! processed by numpydoc !!

   .. py:method:: get_params(deep=True)

      
      Get parameters for this estimator.


      :Parameters:

          **deep** : bool, default=True
              If True, will return the parameters for this estimator and
              contained subobjects that are estimators.

      :Returns:

          **params** : dict
              Parameter names mapped to their values.













      ..
          !! processed by numpydoc !!

   .. py:method:: predict(x)

      
      Predict the closest cluster for each sample.


      :Parameters:

          **x** : univariate time-series
              The input samples.

      :Returns:

          ndarray of shape (n_samples, )
              Index of the cluster each sample belongs to.













      ..
          !! processed by numpydoc !!

   .. py:method:: set_output(*, transform=None)

      
      Set output container.

      See :ref:`sphx_glr_auto_examples_miscellaneous_plot_set_output.py`
      for an example on how to use the API.

      :Parameters:

          **transform** : {"default", "pandas"}, default=None
              Configure output of `transform` and `fit_transform`.
              
              - `"default"`: Default output format of a transformer
              - `"pandas"`: DataFrame output
              - `None`: Transform configuration is unchanged

      :Returns:

          **self** : estimator instance
              Estimator instance.













      ..
          !! processed by numpydoc !!

   .. py:method:: set_params(**params)

      
      Set the parameters of this estimator.

      The method works on simple estimators as well as on nested objects
      (such as :class:`~sklearn.pipeline.Pipeline`). The latter have
      parameters of the form ``<component>__<parameter>`` so that it's
      possible to update each component of a nested object.

      :Parameters:

          **\*\*params** : dict
              Estimator parameters.

      :Returns:

          **self** : estimator instance
              Estimator instance.













      ..
          !! processed by numpydoc !!

   .. py:method:: transform(x)

      
      Transform the input to a cluster distance space.


      :Parameters:

          **x** : univariate time-series
              The input samples.

      :Returns:

          ndarray of shape (n_samples, n_clusters)
              The distance between each sample and each cluster.













      ..
          !! processed by numpydoc !!


.. py:class:: KNeighborsClassifier(n_neighbors=5, *, metric='euclidean', metric_params=None, n_jobs=None)




   
   Classifier implementing k-nearest neighbors.


   :Parameters:

       **n_neighbors** : int, optional
           The number of neighbors.

       **metric** : str, optional
           The distance metric.

       **metric_params** : dict, optional
           Optional parameters to the distance metric.
           
           Read more about the metrics and their parameters in the
           :ref:`User guide <list_of_metrics>`.

       **n_jobs** : int, optional
           The number of parallel jobs.












   :Attributes:

       **classes_** : ndarray of shapel (n_classes, )
           Known class labels.


   ..
       !! processed by numpydoc !!
   .. py:method:: fit(x, y)

      
      Fit the classifier to the training data.


      :Parameters:

          **x** : univariate time-series or multivaraite time-series
              The input samples.

          **y** : array-like of shape (n_samples, )
              The input labels.

      :Returns:

          KNeighborClassifier
              This instance.













      ..
          !! processed by numpydoc !!

   .. py:method:: get_metadata_routing()

      
      Get metadata routing of this object.

      Please check :ref:`User Guide <metadata_routing>` on how the routing
      mechanism works.


      :Returns:

          **routing** : MetadataRequest
              A :class:`~sklearn.utils.metadata_routing.MetadataRequest` encapsulating
              routing information.













      ..
          !! processed by numpydoc !!

   .. py:method:: get_params(deep=True)

      
      Get parameters for this estimator.


      :Parameters:

          **deep** : bool, default=True
              If True, will return the parameters for this estimator and
              contained subobjects that are estimators.

      :Returns:

          **params** : dict
              Parameter names mapped to their values.













      ..
          !! processed by numpydoc !!

   .. py:method:: predict(x)

      
      Compute the class label for the samples in x.


      :Parameters:

          **x** : univariate time-series or multivariate time-series
              The input samples.

      :Returns:

          ndarray of shape (n_samples, )
              The class label for each sample.













      ..
          !! processed by numpydoc !!

   .. py:method:: predict_proba(x)

      
      Compute probability estimates for the samples in x.


      :Parameters:

          **x** : univariate time-series or multivariate time-series
              The input samples.

      :Returns:

          ndarray of shape (n_samples, len(self.classes\_))
              The probability of each class for each sample.













      ..
          !! processed by numpydoc !!

   .. py:method:: score(X, y, sample_weight=None)

      
      Return the mean accuracy on the given test data and labels.

      In multi-label classification, this is the subset accuracy
      which is a harsh metric since you require for each sample that
      each label set be correctly predicted.

      :Parameters:

          **X** : array-like of shape (n_samples, n_features)
              Test samples.

          **y** : array-like of shape (n_samples,) or (n_samples, n_outputs)
              True labels for `X`.

          **sample_weight** : array-like of shape (n_samples,), default=None
              Sample weights.

      :Returns:

          **score** : float
              Mean accuracy of ``self.predict(X)`` w.r.t. `y`.













      ..
          !! processed by numpydoc !!

   .. py:method:: set_params(**params)

      
      Set the parameters of this estimator.

      The method works on simple estimators as well as on nested objects
      (such as :class:`~sklearn.pipeline.Pipeline`). The latter have
      parameters of the form ``<component>__<parameter>`` so that it's
      possible to update each component of a nested object.

      :Parameters:

          **\*\*params** : dict
              Estimator parameters.

      :Returns:

          **self** : estimator instance
              Estimator instance.













      ..
          !! processed by numpydoc !!


.. py:function:: argmin_distance(x, y=None, *, dim=0, k=1, metric='euclidean', metric_params=None, sorted=False, return_distance=False, n_jobs=None)

   
   Find the indicies of the samples with the lowest distance in `Y`.


   :Parameters:

       **x** : univariate time-series or multivariate time-series
           The needle.

       **y** : univariate time-series or multivariate time-series, optional
           The haystack.

       **dim** : int, optional
           The dimension where the distance is computed.

       **k** : int, optional
           The number of closest samples.

       **metric** : str, optional
           The distance metric
           
           See ``_METRICS.keys()`` for a list of supported metrics.

       **metric_params** : dict, optional
           Parameters to the metric.
           
           Read more about the parameters in the
           :ref:`User guide <list_of_metrics>`.

       **sorted** : bool, optional
           Sort the indicies from smallest to largest distance.

       **return_distance** : bool, optional
           Return the distance for the `k` samples.

       **n_jobs** : int, optional
           The number of parallel jobs.

   :Returns:

       **indices** : ndarray of shape (n_samples, k)
           The indices of the samples in `Y` with the smallest distance.

       **distance** : ndarray of shape (n_samples, k), optional
           The distance of the samples in `Y` with the smallest distance.










   .. rubric:: Examples

   >>> from wildoar.distance import argmin_distance
   >>> X = np.array([[1, 2, 3, 4], [10, 1, 2, 3]])
   >>> Y = np.array([[1, 2, 11, 2], [2, 4, 6, 7], [10, 11, 2, 3]])
   >>> argmin_distance(X, Y, k=2, return_distance=True)
   (array([[0, 1],
           [1, 2]]),
    array([[ 8.24621125,  4.79583152],
           [10.24695077, 10.        ]]))



   ..
       !! processed by numpydoc !!

.. py:function:: matrix_profile(x, y=None, *, window=5, dim=0, exclude=None, n_jobs=-1, return_index=False)

   
   Compute the matrix profile.

   - If only ``x`` is given, compute the similarity self-join of every subsequence in
     ``x`` of size ``window`` to its nearest neighbor in `x` excluding trivial matches
     according to the ``exclude`` parameter.
   - If both ``x`` and ``y`` are given, compute the similarity join of every
     subsequenec in ``y`` of size ``window`` to its nearest neighbor in ``x`` excluding
     matches according to the ``exclude`` parameter.

   :Parameters:

       **x** : array-like of shape (n_timestep, ), (n_samples, xn_timestep) or         (n_samples, n_dim, xn_timestep)
           The first time series

       **y** : array-like of shape (n_timestep, ), (n_samples, yn_timestep) or         (n_samples, n_dim, yn_timestep), optional
           The optional second time series. y is broadcast to the shape of x if possible.

       **window** : int or float, optional
           The subsequence size, by default 5
           
           - if float, a fraction of `y.shape[-1]`
           - if int, the exact subsequence size

       **dim** : int, optional
           The dim to compute the matrix profile for, by default 0

       **exclude** : int or float, optional
           The size of the exclusion zone. The default exclusion zone is  0.2 for
           similarity self-join and 0.0 for similarity join.
           
           - if float, expressed as a fraction of the windows size
           - if int, exact size (0 >= exclude < window)

       **n_jobs** : int, optional
           The number of jobs to use when computing the

       **return_index** : bool, optional
           Return the matrix profile index

   :Returns:

       **mp** : ndarray of shape (profile_size, ) or (n_samples, profile_size)
           The matrix profile

       **mpi** : ndarray of shape (profile_size, ) or (n_samples, profile_size), optional
           The matrix profile index








   .. rubric:: Notes

   The `profile_size` depends on the input.

   - If `y` is `None`, `profile_size` is  ``x.shape[-1] - window + 1``
   - If `y` is not `None`, `profile_size` is ``y.shape[-1] - window + 1``

   .. rubric:: References

   Yeh, C. C. M. et al. (2016).
       Matrix profile I: All pairs similarity joins for time series: a unifying view
       that includes motifs, discords and shapelets. In 2016 IEEE 16th international
       conference on data mining (ICDM)

   .. only:: latex

      




   ..
       !! processed by numpydoc !!

.. py:function:: paired_distance(x, y, *, dim='warn', metric='euclidean', metric_params=None, n_jobs=None)

   
   Compute the distance between the i:th time series.


   :Parameters:

       **x** : ndarray of shape (n_samples, n_timestep) or (n_samples, n_dims, n_timestep)
           The input data.

       **y** : ndarray of shape (n_samples, n_timestep) or (n_samples, n_dims, n_timestep)
           The input data. y will be broadcasted to the shape of x.

       **dim** : int or {'mean', 'full'}, optional
           The dim to compute distance.

       **metric** : str or callable, optional
           The distance metric
           
           See ``_METRICS.keys()`` for a list of supported metrics.

       **metric_params** : dict, optional
           Parameters to the metric.
           
           Read more about the parameters in the
           :ref:`User guide <list_of_metrics>`.

       **n_jobs** : int, optional
           The number of parallel jobs.

   :Returns:

       ndarray
           The distances. Return depends on input:
           
           - if x.ndim == 1, return scalar.
           - if dim='full', return ndarray of shape (n_dims, n_samples).
           - if x.ndim > 1, return an ndarray of shape (n_samples, ).













   ..
       !! processed by numpydoc !!

.. py:function:: paired_subsequence_distance(y, x, *, dim=0, metric='euclidean', metric_params=None, return_index=False, n_jobs=None)

   
   Minimum subsequence distance between the i:th subsequence and time series.


   :Parameters:

       **y** : list or ndarray of shape (n_samples, m_timestep)
           Input time series.
           
           - if list, a list of array-like of shape (m_timestep, )

       **x** : ndarray of shape (n_timestep, ), (n_samples, n_timestep)    or (n_samples, n_dims, n_timestep)
           The input data

       **dim** : int, optional
           The dim to search for shapelets

       **metric** : str or callable, optional
           The distance metric
           
           See ``_SUBSEQUENCE_METRICS.keys()`` for a list of supported metrics.

       **metric_params** : dict, optional
           Parameters to the metric.
           
           Read more about the parameters in the
           :ref:`User guide <list_of_subsequence_metrics>`.

       **return_index** : bool, optional
           - if True return the index of the best match. If there are many equally good
             matches, the first match is returned.

       **n_jobs** : int, optional
           The number of parallel jobs to run. Ignored

   :Returns:

       **dist** : float, ndarray
           An array of shape (n_samples, ) with the minumum distance between the i:th
           subsequence and the i:th sample

       **indices** : int, ndarray, optional
           An array of shape (n_samples, ) with the index of the best matching position
           of the i:th subsequence and the i:th sample













   ..
       !! processed by numpydoc !!

.. py:function:: paired_subsequence_match(y, x, threshold=None, *, dim=0, metric='euclidean', metric_params=None, max_matches=None, return_distance=False, n_jobs=None)

   
   Find matching subsequnces.

   Find the positions where the distance is less than the threshold between
   the i:th subsequences and time series.

   - If a `threshold` is given, the default behaviour is to return all matching
     indices in the order of occurrence
   - If no `threshold` is given, the default behaviour is to return the top 10
     matching indicies ordered by distance
   - If both `threshold` and `max_matches` are given, the top matches are returned
     ordered by distance and time series.

   :Parameters:

       **y** : list or ndarray of shape (n_samples, n_timestep)
           Input time series.
           
           - if list, a list of array-like of shape (n_timestep, ) with length n_samples.

       **x** : ndarray of shape (n_samples, n_timestep) or (n_samples, n_dims, n_timestep)
           The input data.

       **threshold** : float, optional
           The distance threshold used to consider a subsequence matching. If no threshold
           is selected, `max_matches` defaults to 10.

       **dim** : int, optional
           The dim to search for shapelets.

       **metric** : str or callable, optional
           The distance metric
           
           See ``_SUBSEQUENCE_METRICS.keys()`` for a list of supported metrics.

       **metric_params** : dict, optional
           Parameters to the metric.
           
           Read more about the parameters in the
           :ref:`User guide <list_of_subsequence_metrics>`.

       **max_matches** : int, optional
           Return the top `max_matches` matches below `threshold`.
           
           - If a `threshold` is given, the default behaviour is to return all matching
             indices in the order of occurrence .
           - If no `threshold` is given, the default behaviour is to return the top 10
             matching indicies ordered by distance
           - If both `threshold` and `max_matches` are given the top matches are returned
             ordered by distance.

       **return_distance** : bool, optional
           If True, return the distance of the match.

       **n_jobs** : int, optional
           The number of parallel jobs to run. Ignored.

   :Returns:

       **indicies** : ndarray
           The start index of matching subsequences. Return depends on input:
           
           - if x.ndim > 1, return an ndarray of shape (n_samples, )
           - if x.ndim == 1, return ndarray of shape (n_matches, ) or None
           
           For each sample, the ndarray contains the .

       **distance** : ndarray, optional
           The distances of matching subsequences. Return depends on input:
           
           - if x.ndim > 1, return an ndarray of shape (n_samples, )
           - if x.ndim == 1, return ndarray of shape (n_matches, ) or None.













   ..
       !! processed by numpydoc !!

.. py:function:: pairwise_distance(x, y=None, *, dim='warn', metric='euclidean', metric_params=None, n_jobs=None)

   
   Compute the distance between subsequences and time series.


   :Parameters:

       **x** : ndarray of shape (n_timestep, ), (x_samples, n_timestep) or             (x_samples, n_dims, n_timestep)
           The input data.

       **y** : ndarray of shape (n_timestep, ), (y_samples, n_timestep) or             (y_samples, n_dims, n_timestep), optional
           The input data.

       **dim** : int or {'mean', 'full'}, optional
           The dim to compute distance.

       **metric** : str or callable, optional
           The distance metric
           
           See ``_METRICS.keys()`` for a list of supported metrics.

       **metric_params** : dict, optional
           Parameters to the metric.
           
           Read more about the parameters in the
           :ref:`User guide <list_of_metrics>`.

       **n_jobs** : int, optional
           The number of parallel jobs.

   :Returns:

       float or ndarray
           The distances. Return depends on input.
           
           - if x.ndim == 1 and y.ndim == 1, scalar.
           - if dim="full", array of shape (n_dims, x_samples, y_samples).
           - if dim="full" and y is None, array of shape (n_dims, x_samples, x_samples).
           - if x.ndim > 1 and y is None, array of shape (x_samples, x_samples).
           - if x.ndim > 1 and y.ndim > 1, array of shape (x_samples, y_samples).
           - if x.ndim == 1 and y.ndim > 1, array of shape (y_samples, ).
           - if y.ndim == 1 and x.ndim > 1, array of shape (x_samples, ).













   ..
       !! processed by numpydoc !!

.. py:function:: pairwise_subsequence_distance(y, x, *, dim=0, metric='euclidean', metric_params=None, return_index=False, n_jobs=None)

   
   Minimum subsequence distance between subsequences and time series.


   :Parameters:

       **y** : list or ndarray of shape (n_subsequences, n_timestep)
           Input time series.
           
           - if list, a list of array-like of shape (n_timestep, )

       **x** : ndarray of shape (n_timestep, ), (n_samples, n_timestep)    or (n_samples, n_dims, n_timestep)
           The input data

       **dim** : int, optional
           The dim to search for subsequence

       **metric** : str or callable, optional
           The distance metric
           
           See ``_SUBSEQUENCE_METRICS.keys()`` for a list of supported metrics.

       **metric_params** : dict, optional
           Parameters to the metric.
           
           Read more about the parameters in the
           :ref:`User guide <list_of_subsequence_metrics>`.

       **return_index** : bool, optional
           - if True return the index of the best match. If there are many equally good
             matches, the first match is returned.

   :Returns:

       **dist** : float, ndarray
           The minumum distance. Return depends on input:
           
           - if len(y) > 1 and x.ndim > 1, return an array of shape
             (n_samples, n_subsequences).
           - if len(y) == 1, return an array of shape (n_samples, ).
           - if x.ndim == 1, return an array of shape (n_subsequences, ).
           - if x.ndim == 1 and len(y) == 1, return scalar.

       **indices** : int, ndarray, optional
            The start index of the minumum distance. Return dependes on input:
           
           - if len(y) > 1 and x.ndim > 1, return an array of shape
             (n_samples, n_subsequences).
           - if len(y) == 1, return an array of shape (n_samples, ).
           - if x.ndim == 1, return an array of shape (n_subsequences, ).
           - if x.ndim == 1 and len(y) == 1, return scalar.













   ..
       !! processed by numpydoc !!

.. py:function:: subsequence_match(y, x, threshold=None, *, dim=0, metric='euclidean', metric_params=None, max_matches=None, exclude=None, return_distance=False, n_jobs=None)

   
   Find matching subsequnces.

   Find the positions where the distance is less than the threshold between
   the subsequence and all time series.

   - If a `threshold` is given, the default behaviour is to return all matching
     indices in the order of occurrence
   - If no `threshold` is given, the default behaviour is to return the top 10
     matching indicies ordered by distance
   - If both `threshold` and `max_matches` are given, the top matches are returned
     ordered by distance.

   :Parameters:

       **y** : array-like of shape (yn_timestep, )
           The subsequence

       **x** : ndarray of shape (n_timestep, ), (n_samples, n_timestep)    or (n_samples, n_dims, n_timestep)
           The input data

       **threshold** : str, float or callable, optional
           The distance threshold used to consider a subsequence matching. If no threshold
           is selected, `max_matches` defaults to 10.
           
           - if float, return all matches closer than threshold
           - if callable, return all matches closer than the treshold computed by the
             threshold function, given all distances to the subsequence
           - if str, return all matches according to the named threshold.

       **dim** : int, optional
           The dim to search for shapelets

       **metric** : str or callable, optional
           The distance metric
           
           See ``_SUBSEQUENCE_METRICS.keys()`` for a list of supported metrics.

       **metric_params** : dict, optional
           Parameters to the metric.
           
           Read more about the parameters in the
           :ref:`User guide <list_of_subsequence_metrics>`.

       **max_matches** : int, optional
           Return the top `max_matches` matches below `threshold`.

       **exclude** : float or int, optional
           Exclude trivial matches in the vicinity of the match.
           
           - if float, the exclusion zone is computed as ``math.ceil(exclude * y.size)``
           - if int, the exclusion zone is exact
           
           A match is considered trivial if a match with lower distance is within `exclude`
           timesteps of another match with higher distance.

       **return_distance** : bool, optional
           - if True, return the distance of the match

       **n_jobs** : int, optional
           The number of parallel jobs to run. Ignored

   :Returns:

       **indicies** : ndarray
           The start index of matching subsequences. Return depends on input:
           
           - if x.ndim > 1, return an ndarray of shape (n_samples, )
           - if x.ndim == 1, return ndarray of shape (n_matches, ) or None
           
           For each sample, the ndarray contains the .

       **distance** : ndarray, optional
           The distances of matching subsequences. Return depends on input:
           
           - if x.ndim > 1, return an ndarray of shape (n_samples, )
           - if x.ndim == 1, return ndarray of shape (n_matches, ) or None













   ..
       !! processed by numpydoc !!

