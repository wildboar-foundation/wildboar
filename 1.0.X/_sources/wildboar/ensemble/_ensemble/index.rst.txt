:orphan:

:py:mod:`wildboar.ensemble._ensemble`
=====================================

.. py:module:: wildboar.ensemble._ensemble


Module Contents
---------------

Classes
~~~~~~~

.. autoapisummary::

   wildboar.ensemble._ensemble.ShapeletForestMixin
   wildboar.ensemble._ensemble.BaseShapeletForestClassifier
   wildboar.ensemble._ensemble.ShapeletForestClassifier
   wildboar.ensemble._ensemble.ExtraShapeletTreesClassifier
   wildboar.ensemble._ensemble.BaseShapeletForestRegressor
   wildboar.ensemble._ensemble.ShapeletForestRegressor
   wildboar.ensemble._ensemble.ExtraShapeletTreesRegressor
   wildboar.ensemble._ensemble.ShapeletForestEmbedding
   wildboar.ensemble._ensemble.IsolationShapeletForest




.. py:class:: ShapeletForestMixin

   .. py:method:: apply(x)


   .. py:method:: decision_function(x)



.. py:class:: BaseShapeletForestClassifier(base_estimator, *, estimator_params=tuple(), oob_score=False, n_estimators=100, max_depth=None, min_samples_split=2, n_shapelets=10, min_shapelet_size=0, max_shapelet_size=1, metric='euclidean', metric_params=None, bootstrap=True, warm_start=False, n_jobs=None, random_state=None)

   Bases: :py:obj:`ShapeletForestMixin`, :py:obj:`sklearn.ensemble.BaggingClassifier`

   Base class for shapelet forest classifiers.

   .. warning::

      This class should not be used directly. Use derived classes
      instead.

   .. py:method:: predict(X, check_input=True)

      Predict class for X.

      The predicted class of an input sample is computed as the class with
      the highest mean predicted probability. If base estimators do not
      implement a ``predict_proba`` method, then it resorts to voting.

      :param X: The training input samples. Sparse matrices are accepted only if
                they are supported by the base estimator.
      :type X: {array-like, sparse matrix} of shape (n_samples, n_features)

      :returns: **y** -- The predicted classes.
      :rtype: ndarray of shape (n_samples,)


   .. py:method:: predict_proba(x, check_input=True)

      Predict class probabilities for X.

      The predicted class probabilities of an input sample is computed as
      the mean predicted class probabilities of the base estimators in the
      ensemble. If base estimators do not implement a ``predict_proba``
      method, then it resorts to voting and the predicted class probabilities
      of an input sample represents the proportion of estimators predicting
      each class.

      :param X: The training input samples. Sparse matrices are accepted only if
                they are supported by the base estimator.
      :type X: {array-like, sparse matrix} of shape (n_samples, n_features)

      :returns: **p** -- The class probabilities of the input samples. The order of the
                classes corresponds to that in the attribute :term:`classes_`.
      :rtype: ndarray of shape (n_samples, n_classes)


   .. py:method:: predict_log_proba(x, check_input=True)

      Predict class log-probabilities for X.

      The predicted class log-probabilities of an input sample is computed as
      the log of the mean predicted class probabilities of the base
      estimators in the ensemble.

      :param X: The training input samples. Sparse matrices are accepted only if
                they are supported by the base estimator.
      :type X: {array-like, sparse matrix} of shape (n_samples, n_features)

      :returns: **p** -- The class log-probabilities of the input samples. The order of the
                classes corresponds to that in the attribute :term:`classes_`.
      :rtype: ndarray of shape (n_samples, n_classes)


   .. py:method:: fit(x, y, sample_weight=None, check_input=True)

      Fit a random shapelet forest classifier



.. py:class:: ShapeletForestClassifier(*, n_estimators=100, n_shapelets=10, max_depth=None, min_samples_split=2, min_shapelet_size=0, max_shapelet_size=1, metric='euclidean', metric_params=None, oob_score=False, bootstrap=True, warm_start=False, n_jobs=None, random_state=None)

   Bases: :py:obj:`BaseShapeletForestClassifier`

   An ensemble of random shapelet tree classifiers.

   .. rubric:: Examples

   >>> from wildboar.ensemble import ShapeletForestClassifier
   >>> from wildboar.datasets import load_synthetic_control
   >>> x, y = load_synthetic_control()
   >>> f = ShapeletForestClassifier(n_estimators=100, metric='scaled_euclidean')
   >>> f.fit(x, y)
   >>> y_hat = f.predict(x)


.. py:class:: ExtraShapeletTreesClassifier(*, n_estimators=100, max_depth=None, min_samples_split=2, min_shapelet_size=0, max_shapelet_size=1, metric='euclidean', metric_params=None, oob_score=False, bootstrap=True, warm_start=False, n_jobs=None, random_state=None)

   Bases: :py:obj:`BaseShapeletForestClassifier`

   An ensemble of extremely random shapelet trees for time series regression.

   .. rubric:: Examples

   >>> from wildboar.ensemble import ExtraShapeletTreesClassifier
   >>> from wildboar.datasets import load_synthetic_control
   >>> x, y = load_synthetic_control()
   >>> f = ExtraShapeletTreesClassifier(n_estimators=100, metric='scaled_euclidean')
   >>> f.fit(x, y)
   >>> y_hat = f.predict(x)


.. py:class:: BaseShapeletForestRegressor(base_estimator, *, estimator_params=tuple(), oob_score=False, n_estimators=100, max_depth=None, min_samples_split=2, n_shapelets=10, min_shapelet_size=0.0, max_shapelet_size=1.0, metric='euclidean', metric_params=None, bootstrap=True, warm_start=False, n_jobs=None, random_state=None)

   Bases: :py:obj:`ShapeletForestMixin`, :py:obj:`sklearn.ensemble.BaggingRegressor`

   Base class for shapelet forest regressors.

   .. warning::

      This class should not be used directly. Use derived classes
      instead.

   .. py:method:: predict(x, check_input=True)

      Predict regression target for X.

      The predicted regression target of an input sample is computed as the
      mean predicted regression targets of the estimators in the ensemble.

      :param X: The training input samples. Sparse matrices are accepted only if
                they are supported by the base estimator.
      :type X: {array-like, sparse matrix} of shape (n_samples, n_features)

      :returns: **y** -- The predicted values.
      :rtype: ndarray of shape (n_samples,)


   .. py:method:: fit(x, y, sample_weight=None, check_input=True)

      Fit a random shapelet forest regressor



.. py:class:: ShapeletForestRegressor(*, n_estimators=100, n_shapelets=10, max_depth=None, min_samples_split=2, min_shapelet_size=0, max_shapelet_size=1, metric='euclidean', metric_params=None, oob_score=False, bootstrap=True, warm_start=False, n_jobs=None, random_state=None)

   Bases: :py:obj:`BaseShapeletForestRegressor`

   An ensemble of random shapelet regression trees.

   .. rubric:: Examples

   >>> from wildboar.ensemble import ShapeletForestRegressor
   >>> from wildboar.datasets import load_synthetic_control
   >>> x, y = load_synthetic_control()
   >>> f = ShapeletForestRegressor(n_estimators=100, metric='scaled_euclidean')
   >>> f.fit(x, y)
   >>> y_hat = f.predict(x)


.. py:class:: ExtraShapeletTreesRegressor(*, n_estimators=100, max_depth=None, min_samples_split=2, min_shapelet_size=0, max_shapelet_size=1, metric='euclidean', metric_params=None, oob_score=False, bootstrap=True, warm_start=False, n_jobs=None, random_state=None)

   Bases: :py:obj:`BaseShapeletForestRegressor`

   An ensemble of extremely random shapelet trees for time series regression.

   .. rubric:: Examples

   >>> from wildboar.ensemble import ExtraShapeletTreesRegressor
   >>> from wildboar.datasets import load_synthetic_control
   >>> x, y = load_synthetic_control()
   >>> f = ExtraShapeletTreesRegressor(n_estimators=100, metric='scaled_euclidean')
   >>> f.fit(x, y)
   >>> y_hat = f.predict(x)


.. py:class:: ShapeletForestEmbedding(n_estimators=100, *, n_shapelets=1, max_depth=5, min_samples_split=2, min_shapelet_size=0, max_shapelet_size=1, metric='euclidean', metric_params=None, bootstrap=True, warm_start=False, n_jobs=None, sparse_output=True, random_state=None)

   Bases: :py:obj:`BaseShapeletForestRegressor`

   An ensemble of random shapelet trees

   An unsupervised transformation of a time series dataset
   to a high-dimensional sparse representation. A time series i
   indexed by the leaf that it falls into. This leads to a binary
   coding of a time series with as many ones as trees in the forest.

   The dimensionality of the resulting representation is
   ``<= n_estimators * 2^max_depth``

   .. py:method:: fit(x, y=None, sample_weight=None, check_input=True)

      Fit a random shapelet forest regressor


   .. py:method:: fit_transform(x, y=None, sample_weight=None, check_input=True)


   .. py:method:: transform(x)



.. py:class:: IsolationShapeletForest(*, n_estimators=100, bootstrap=False, n_jobs=None, min_shapelet_size=0, max_shapelet_size=1, min_samples_split=2, max_samples='auto', contamination='auto', contamination_set='training', warm_start=False, metric='euclidean', metric_params=None, random_state=None)

   Bases: :py:obj:`ShapeletForestMixin`, :py:obj:`sklearn.base.OutlierMixin`, :py:obj:`sklearn.ensemble._bagging.BaseBagging`

   A isolation shapelet forest.

   .. versionadded:: 0.3.5

   .. attribute:: offset_

      The offset for computing the final decision

      :type: float

   .. rubric:: Examples

   >>> from wildboar.ensemble import IsolationShapeletForest
   >>> from wildboar.datasets import load_two_lead_ecg
   >>> from model_selection.outlier import train_test_split
   >>> from sklearn.metrics import balanced_accuracy_score
   >>> x, y = load_two_lead_ecg("two_lead_ecg")
   >>> x_train, x_test, y_train, y_test = train_test_split(x, y, 1, test_size=0.2, anomalies_train_size=0.05)
   >>> f = IsolationShapeletForest(n_estimators=100, contamination=balanced_accuracy_score)
   >>> f.fit(x_train, y_train)
   >>> y_pred = f.predict(x_test)
   >>> balanced_accuracy_score(y_test, y_pred)

   Or using default offset threshold

   >>> from wildboar.ensemble import IsolationShapeletForest
   >>> from wildboar.datasets import load_two_lead_ecg
   >>> from model_selection.outlier import train_test_split
   >>> from sklearn.metrics import balanced_accuracy_score
   >>> f = IsolationShapeletForest()
   >>> x, y = load_two_lead_ecg("two_lead_ecg")
   >>> x_train, x_test, y_train, y_test = train_test_split(x, y, 1, test_size=0.2, anomalies_train_size=0.05)
   >>> f.fit(x_train)
   >>> y_pred = f.predict(x_test)
   >>> balanced_accuracy_score(y_test, y_pred)

   .. py:method:: fit(x, y=None, sample_weight=None, check_input=True)

      Build a Bagging ensemble of estimators from the training set (X, y).

      :param X: The training input samples. Sparse matrices are accepted only if
                they are supported by the base estimator.
      :type X: {array-like, sparse matrix} of shape (n_samples, n_features)
      :param y: The target values (class labels in classification, real numbers in
                regression).
      :type y: array-like of shape (n_samples,)
      :param sample_weight: Sample weights. If None, then samples are equally weighted.
                            Note that this is supported only if the base estimator supports
                            sample weighting.
      :type sample_weight: array-like of shape (n_samples,), default=None

      :returns: **self** -- Fitted estimator.
      :rtype: object


   .. py:method:: predict(x)


   .. py:method:: decision_function(x)


   .. py:method:: score_samples(x)



